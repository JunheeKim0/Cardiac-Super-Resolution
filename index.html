<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Project Title — Template</title>
  <meta name="description" content="MGDCR." />
  <style>
    :root {
      --bg: #ffffff;
      --fg: #111111;
      --muted: #666;
      --link: #0b57d0;
      --border: #e5e7eb;
      --chip: #f5f5f5;
      --code: #0f172a;
      --code-bg: #f8fafc;
      --shadow: 0 1px 2px rgba(0,0,0,.05), 0 4px 12px rgba(0,0,0,.06);
    }
    html, body { background: var(--bg); color: var(--fg); margin: 0; font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Inter, "Apple SD Gothic Neo", "Noto Sans KR", sans-serif; line-height: 1.6; }
    a { color: var(--link); text-decoration: none; }
    a:hover { text-decoration: underline; }
    .container { max-width: 980px; margin: 0 auto; padding: 2rem 1rem 5rem; }
    header { text-align: center; margin-bottom: 2rem; }
    header h1 { font-size: clamp(1.6rem, 2.8vw, 2.4rem); margin: 0.5rem 0 0.75rem; line-height: 1.25; }
    .authors { display: inline-flex; flex-wrap: wrap; gap: .5rem .75rem; align-items: center; justify-content: center; font-size: .95rem; color: var(--muted); }
    .authors a { color: inherit; border-bottom: 1px dotted var(--muted); }
    .affil { margin-top: .25rem; font-weight: 500; }

    .hero {
      margin: 2rem auto;
      max-width: 100%;
      border: 1px solid var(--border);
      border-radius: 10px;
      overflow: hidden;
      box-shadow: var(--shadow);

      display: flex;
      justify-content: center;
      gap: 24px;
      padding: 16px;
    }
    
    .hero img {
      width: 48%;
      height: auto;
      display: block;
    }

    .cta-row { display: flex; flex-wrap: wrap; gap: .75rem; justify-content: center; margin: 1.25rem 0 2rem; }
    .btn { display: inline-flex; align-items: center; gap: .5rem; padding: .6rem .9rem; border: 1px solid var(--border); border-radius: 999px; background: var(--chip); color: var(--fg); font-weight: 600; box-shadow: var(--shadow); }
    .btn:hover { filter: brightness(0.98); text-decoration: none; }

    section { margin: 2.25rem 0; }
    section h2 { font-size: 1.4rem; margin: 0 0 .75rem; border-bottom: 1px solid var(--border); padding-bottom: .4rem; }
    p { margin: .6rem 0; }

    .figure { margin: 1rem 0; border: 1px solid var(--border); border-radius: 10px; overflow: hidden; box-shadow: var(--shadow); }
    .figure img { width: 100%; display: block; }
    .caption { font-size: .9rem; color: var(--muted); padding: .5rem .75rem; background: #fafafa; border-top: 1px solid var(--border); }

    .gallery { display: grid; grid-template-columns: repeat(auto-fill, minmax(180px, 1fr)); gap: .75rem; }
    .gallery img { width: 100%; height: auto; border-radius: 8px; border: 1px solid var(--border); box-shadow: var(--shadow); background: #fff; }

    .pager { display: flex; justify-content: center; gap: 1rem; margin-top: .75rem; }
    .pager button { padding: .4rem .8rem; border: 1px solid var(--border); background: var(--bg); border-radius: 8px; cursor: pointer; }

    pre { background: var(--code-bg); color: var(--code); border: 1px solid var(--border); border-radius: 8px; padding: 1rem; overflow-x: auto; }

    footer { margin-top: 3rem; padding-top: 1rem; border-top: 1px solid var(--border); color: var(--muted); font-size: .95rem; }

    /* Simple anchor nav */
    .topnav { position: sticky; top: 0; backdrop-filter: saturate(1.2) blur(6px); background: rgba(255,255,255,0.7); border-bottom: 1px solid var(--border); z-index: 10; }
    .topnav .inner { max-width: 980px; margin: 0 auto; padding: .5rem 1rem; display: flex; gap: .75rem; flex-wrap: wrap; align-items: center; }
    .chip { padding: .35rem .6rem; border: 1px solid var(--border); border-radius: 999px; background: var(--chip); font-weight: 600; }
  </style>
</head>
<body>
  <div class="topnav">
    <div class="inner">
      <a class="chip" href="#abstract">Abstract</a>
      <a class="chip" href="#method">Method</a>
      <a class="chip" href="#results">Results</a>
      <!-- <a class="chip" href="#video">Demo Video</a> -->
      <a class="chip" href="#weights">Model Weights</a>
      <!-- <a class="chip" href="#bibtex">BibTeX</a> -->
    </div>
  </div>

  <main class="container">
    <header>
      <h1>MGDCR: Multi-View-Guided Diffusion Model for Cardiac Volume Reconstruction</h1>
      <div class="authors">
        <!-- Replace # with your links -->
        <a href="#">Jun hee Kim</a>,
        <a href="#">Jin Kyu Gahm</a>
      </div>
      <div class="affil">IC&ML / Pusan University</div>

      <div class="hero">
        <img src="img/output_9frames.gif" alt="Teaser figure 1" />
        <img src="img/output.gif" alt="Teaser figure 2" />
      </div>

      <div class="cta-row">
        <a class="btn" href="https://github.com/JunheeKim0/cine-SR" target="_blank" rel="noopener">[Code]</a>
        <a class="btn" href="#">[Paper]</a>
        <!-- <a class="btn" href="#bibtex">[BibTeX]</a>
        <a class="btn" href="#video">[Demo Video]</a> -->
      </div>
    </header>

    <section id="abstract">
      <h2>Abstract</h2>
      <p>
          4D cine MRI is essential for cardiac function assessment. It offers continuous observation of ventricular dynamics, but its low through-plane resolution compromises anatomical continuity between slices and degrades the accuracy of essential clinical metrics, such as ventricular boundary delineation and ejection fraction (EF) calculation. We present MGDCR (Long-Axis Guided Diffusion Autoencoder), which integrates guidance from long-axis (LAX) views into an unsupervised through-plane interpolation framework. A diffusion autoencoder is pre-trained on 400 healthy-subject SAX volumes from UK Biobank and fine-tuned on 230 heart-failure cases. Given adjacent SAX slices, we synthesize intermediate planes by interpolating disentangled semantic and stochastic latents, then refine them via inverse optimization that aligns LAX-plane projections, enforces slice-to-slice continuity, and regularizes deviation from interpolated seeds. The method improves structural consistency and continuity over existing models, as shown by higher Dice and lower HD95, with visualizations confirming chamber-level coherence. This approach provides a practical solution to cine-MRI resolution limits and potential for future volumetric and functional analyses.
      </p>
    </section>

    <section id="method">
      <h2>Method</h2>
      <p>
        For the super-resolution task, MGDCR additionally takes one condition : Long-Axis cine MRI. 
      </p>
      <figure class="figure">
        <img src="img/overview_figure.png" alt="Overview of the proposed MGDCR framework" />
        <figcaption class="caption">(a) Overview of MGDCR </figcaption>
      </figure>
      <p>
        The proposed method introduces a structure-aware latent interpolation and optimization framework for reconstructing high-resolution SAX volumes from sparse 2D inputs. First, a Diffusion Autoencoder (DiffAE) is pretrained to disentangle each SAX slice into two latent components: a semantic representation that encodes anatomical geometry and a stochastic representation that captures fine-scale variations. Without paired supervision, the model learns to regularize each branch with its own prior, ensuring meaningful structure and realistic details. During reconstruction, two adjacent SAX slices are encoded, and their latent features are interpolated: semantic codes are linearly blended to preserve structural fidelity, while stochastic codes are interpolated via spherical interpolation (slerp) to generate smooth, natural details. The interpolated latent pair is then decoded to synthesize the intermediate slice, and repeating this process across all gaps yields an initial high-resolution SAX volume. To enhance global anatomical consistency, a long-axis (LAX) guided inverse optimization step refines each slice’s latent representation by enforcing alignment with the acquired LAX projections, maintaining slice-to-slice continuity, and constraining deviations from the interpolated seeds. These three complementary objectives—projection consistency, slice continuity, and latent regularization—jointly balance local accuracy and global coherence. Because the pretrained decoder acts as a fixed generative prior, optimization remains within a valid latent manifold, preventing implausible reconstructions. As a result, the method achieves anatomically faithful, volumetrically consistent reconstructions that respect both SAX local detail and LAX global guidance
      </p>
      <!-- <figure class="figure">
        <img src="assets/method_fig_2.jpg" alt="Attention mechanism" />
        <figcaption class="caption">(b) Attention / component details (placeholder).</figcaption>
      </figure> -->
    </section>

    <section id="results">
      <h2>Results</h2>
      <p>Segmentation performance (Dice coefficient ↑ and Hausdorff distance HD95 ↓) of different reconstruction methods evaluated on LAX views (2/3/4-ch). Best values are shown in <strong>bold</strong>. MYO: myocardium; LV: left ventricle; RV: right ventricle.</p>

      <div id="jh-carousel" style="position:relative; border:1px solid #e5e7eb; border-radius:10px; overflow:hidden; box-shadow:0 1px 2px rgba(0,0,0,.05), 0 4px 12px rgba(0,0,0,.06); background:#fff;">

        <div class="jh-slide jh-active" style="display:block;">
          <img src="img/result/140.png" alt="example 1" loading="lazy" style="display:block; width:100%; height:auto;">
        </div>
        <div class="jh-slide" style="display:none;">
          <img src="img/result/297.png" alt="example 2" loading="lazy" style="display:block; width:100%; height:auto;">
        </div>
        <div class="jh-slide" style="display:none;">
          <img src="img/result/327.png" alt="example 3" loading="lazy" style="display:block; width:100%; height:auto;">
        </div>
        <div class="jh-slide" style="display:none;">
          <img src="img/result/712.png" alt="example 4" loading="lazy" style="display:block; width:100%; height:auto;">
        </div>
        <div class="jh-slide" style="display:none;">
          <img src="img/result/732.png" alt="example 4" loading="lazy" style="display:block; width:100%; height:auto;">
        </div>
        <!-- 좌/우 화살표: 기본 반투명, hover 시 뚜렷 -->
        <button id="jh-prev"
          aria-label="Previous"
          style="position:absolute; top:50%; left:12px; transform:translateY(-50%);
                width:48px; height:48px; border:none; border-radius:50%;
                background:rgba(0,0,0,.25); color:#fff; font-size:28px; line-height:48px; text-align:center; cursor:pointer; opacity:.0;"
          onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='.0'">❮</button>

        <button id="jh-next"
          aria-label="Next"
          style="position:absolute; top:50%; right:12px; transform:translateY(-50%);
                width:48px; height:48px; border:none; border-radius:50%;
                background:rgba(0,0,0,.25); color:#fff; font-size:28px; line-height:48px; text-align:center; cursor:pointer; opacity:.0;"
          onmouseover="this.style.opacity='1'" onmouseout="this.style.opacity='.0'">❯</button>
      </div>

      <!-- 아주 작은 점 네비(선택) -->
      <div id="jh-dots" style="display:flex; gap:6px; justify-content:center; margin-top:10px;"></div>

      <script>
        (function(){
          const root = document.getElementById('jh-carousel');
          const slides = Array.from(root.querySelectorAll('.jh-slide'));
          const prev   = document.getElementById('jh-prev');
          const next   = document.getElementById('jh-next');
          const dotsWrap = document.getElementById('jh-dots');

          let idx = 0;
          function show(i){
            slides.forEach((s,k)=>{ s.style.display = (k===i)?'block':'none'; });
            idx = i;
            // dots 업데이트
            if (dotsWrap && dotsWrap.children.length === slides.length){
              [...dotsWrap.children].forEach((d,k)=> d.style.background = (k===i)?'#111':'#ccc');
            }
          }
          function go(delta){
            const n = slides.length;
            const ni = (idx + delta + n) % n;
            show(ni);
          }

          // 버튼
          prev.addEventListener('click', ()=>go(-1));
          next.addEventListener('click', ()=>go(+1));

          // 키보드
          root.setAttribute('tabindex','0');
          root.addEventListener('keydown', (e)=>{
            if (e.key === 'ArrowLeft')  go(-1);
            if (e.key === 'ArrowRight') go(+1);
          });

          // 점 네비 생성
          dotsWrap.innerHTML = '';
          slides.forEach((_,i)=>{
            const b = document.createElement('button');
            b.style.cssText = 'width:8px;height:8px;border-radius:50%;border:none;cursor:pointer;background:#ccc;';
            b.addEventListener('click', ()=>show(i));
            dotsWrap.appendChild(b);
          });

          // 초기 표시
          show(0);
        })();
      </script>
    </section>


    <!-- <section id="video">
      <h2>Demo Video</h2>
      <div class="figure" style="aspect-ratio: 16/9;">
        <iframe width="100%" height="100%" src="https://www.youtube.com/embed/VIDEO_ID" title="Demo Video" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe>
      </div>
    </section> -->


    <!-- <section id="bibtex">
      <h2>BibTeX</h2>
      <pre>
@article{yourkey2025yourpaper,
  title={Your Paper Title},
  author={Surname, First and Coauthor, Second},
  journal={arXiv preprint arXiv:0000.00000},
  year={2025}
}
      </pre>
    </section> -->

    <footer>
      <p>Project page template adapted for academic use. Credits to prior templates used widely in the community.</p>
    </footer>
  </main>

  <script>
    // Extremely simple pager: it swaps which image set is visible when you have multiple pages per group.
    // To keep this a single-file template, we just rotate images order; for real projects, replace with your own logic.
    function rotate(group, dir) {
      const gal = document.querySelector('.gallery[data-group="' + group + '"]');
      if (!gal) return;
      const imgs = Array.from(gal.querySelectorAll('img'));
      if (imgs.length <= 1) return;
      if (dir === 'prev') {
        gal.insertBefore(imgs[imgs.length - 1], imgs[0]);
      } else {
        gal.appendChild(imgs[0]);
      }
    }
    document.querySelectorAll('[data-prev]').forEach(btn => btn.addEventListener('click', () => rotate(btn.getAttribute('data-prev'), 'prev')));
    document.querySelectorAll('[data-next]').forEach(btn => btn.addEventListener('click', () => rotate(btn.getAttribute('data-next'), 'next')));
  </script>
</body>
</html>



